<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Mind on Mind</title>
 <link href="http://yangzetian.github.com/atom.xml" rel="self"/>
 <link href="http://yangzetian.github.com"/>
 <updated>2012-07-24T22:16:49+08:00</updated>
 <id>http://yangzetian.github.com</id>
 <author>
   <name>Zetian Yang</name>
   <email>zetain.yang@gmail.com</email>
 </author>

 
 <entry>
   <title>宇宙终极配色方案，适用 vim, emacs, textmate, xterm, urxvt</title>
   <link href="http://yangzetian.github.com/2012/07/14/the-ultimate-colorscheme"/>
   <updated>2012-07-14t11:34:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/07/14/the-ultimate-colorscheme</id>
   <content type="html">&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;content-style-type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;http://ethanschoonover.com/solarized/img/solarized-yinyang.png&quot; alt=&quot;solarized&quot;/&gt;
&lt;p&gt;如果你是一个习惯用文本编辑器写东西（代码，文章）的人，你是否跟我一样为一套满意的配色方案(colorscheme)苦苦追寻了很久？就在昨天，我终于找到了令我折服的配色方案：&lt;a href=&quot;http://ethanschoonover.com/solarized&quot;&gt;solarized&lt;/a&gt;。我称它为你需要的最后一个配色方案。&lt;/p&gt;
&lt;p&gt;这套配色由 &lt;a href=&quot;ethanschoonover.com&quot;&gt;ethan schoonover&lt;/a&gt; 精心挑选的十六种颜色组成，前八种为单色(monotones)，后八种为强调色(accent colors)。作者按照一定的亮度关系设计出来的这些颜色，使得文本不仅清晰易读，并且具有优异的对比度，就算长时间阅读眼睛也不觉得难受。&lt;/p&gt;
&lt;p&gt;作者最初将它设计为 vim 的插件，但很快便被移植到了几乎任何可以设置调色板的地方，包括文本编辑器(emacs, textmate, visual studio)，终端模拟器，mutt，以及 photoshop, gimp 等。我将它应用在了 gnome-terminal 及 vim 中，效果非常不错。配置方法可以参考我的笔记：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://yangzetian.github.com/yang-tech-notes/linux/gnome_terminal_solarized.html&quot;&gt;solarized gnome-terminal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yangzetian.github.com/yang-tech-notes/vim/vim_solarized.html#vim-solarized&quot;&gt;solarized vim&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以参考&lt;a href=&quot;http://ethanschoonover.com/solarized&quot;&gt;官网&lt;/a&gt;的介绍后自己折腾。&lt;/p&gt;
&lt;p&gt;如果你也和设计者 schoonover 一样喜欢在阳光明媚的日子坐在树荫下读书，那就赶快来尝试一下这套配色方案吧！&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>我的技术笔记上线啦!</title>
   <link href="http://yangzetian.github.com/2012/07/05/notes-online"/>
   <updated>2012-07-05t23:35:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/07/05/notes-online</id>
   <content type="html">&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;content-style-type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;经过几天的酝酿，我采用 &lt;a href=&quot;http://sphinx.pocco.org&quot;&gt;sphinx&lt;/a&gt; 搭建的 wiki 式技术&lt;a href=&quot;http://yangzetian.github.com/yang-tech-notes&quot;&gt;笔记&lt;/a&gt;终于上线了 :-)&lt;/p&gt;
&lt;p&gt;很久之前就看到&lt;a href=&quot;http://wiki.ktmud.com/index.html&quot;&gt;迟丘&lt;/a&gt;用&lt;a href=&quot;http://code.google.com/p/vimwiki&quot;&gt;vimwiki&lt;/a&gt;编写的页面十分漂亮，当时就开始琢磨着想自己哪天也建一个类似的 wiki 平台。后来又从 &lt;a href=&quot;http://beiyuu.com&quot;&gt;beiyuu&lt;/a&gt; 的一篇&lt;a href=&quot;http://beiyuu.com/why-blog&quot;&gt;文章&lt;/a&gt;中体会到 wiki 与博客的差别。按那篇文章的观点，我写博客的初衷（记录自己在使用 linux 过程中遇到的问题和收获）或许采用 wiki 的形式更加适合。&lt;/p&gt;
&lt;p&gt;当然，现在这个博客早不是一个技术笔记了，而且正与技术渐行渐远。但归根结底来说我还是要靠技术混饭吃的，而技术又需要点点滴滴的持久积累。因此该技术笔记便顺利成章地出现了。它将记录与 linux, python, scientific computing, vim 等技术相关的内容，主要涉及各种工具、技术的配置与使用方法。这些往往属于比较零散的知识点，而那些对相关技术的总结性文章则将继续发表在博客中。&lt;/p&gt;
&lt;p&gt;wiki 其实有很多方便快捷的搭建方法，比如新兴的 &lt;a href=&quot;http://www.tryscribble.com&quot;&gt;scribble&lt;/a&gt;，将建 wiki 变得和用记事本一样简单直接，而且相当美观。但在衡量了易用性与自由性之后，我最终选择了 sphinx 作为自己的 wiki 引擎，这里要十分感谢 &lt;a href=&quot;http://deep.tw&quot;&gt;daniel lin&lt;/a&gt; 的启发！&lt;/p&gt;
&lt;p&gt;这个笔记完全开源，依然是托管在 github 上，源文件与编译好的网页均在 &lt;a href=&quot;https://github.com/yangzetian/yang-tech-notes&quot;&gt;yang-tech-notes&lt;/a&gt;。我的第一篇笔记与 &lt;a href=&quot;http://www.gnu.org/software/screen&quot;&gt;gnu screen&lt;/a&gt; 有关，可以在&lt;a href=&quot;http://yangzetian.github.com/yang-tech-notes/linux/screen.html&quot;&gt;这儿&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;最后，祝此笔记开门大吉，成果多多！&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>毕业的颜色</title>
   <link href="http://yangzetian.github.com/2012/06/10/graduate-colors"/>
   <updated>2012-06-10t09:45:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/06/10/graduate-colors</id>
   <content type="html">&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;6号是我毕业答辩的日子，现在回想起来，仍觉得那一天是如此漫长。&lt;/p&gt;
&lt;p&gt;起因要追溯到去年的这个时候，我决定不以计算机继续作为自己毕业后的职业。这并不是一个莽撞作出的决定，因为从大二起我就尝试在计算机学院内寻找自己感兴趣的方向，但各实验室所作的工作与氛围均不能唤起我的任何激情。我不甘心把自己的青春年华花在沉闷的工程项目上，因此我开始寻求计算机以外的道路。&lt;/p&gt;
&lt;p&gt;一个偶然的机会，我突然意识到人类视觉的不寻常之处，并和子沛进行了讨论。后来他推荐我去读索尔索的那本&lt;a href=&quot;http://book.douban.com/subject/3171969/&quot;&gt;《认知心理学》&lt;/a&gt;，那是我第一次了解到原来心理学的研究对象是人类的心智。或许是冥冥之中的安排，在我急切的想找到一个人生出口的时候，『认知』这个既酷又神秘的词语打开了我的视野。后来我报名参加了北师大的认知神经科学暑期学校，并幸运地加入了 Liu Lab。从那时起，来自身边家人、朋友、同学的无休止疑问便开始了。&lt;/p&gt;
&lt;p&gt;我想我们每个人都有自己的思维空间，空间内是我们已了解接受的东西，而空间外则是从未被我们意识到的东西。对于那些从未接触过的事物，有些人的反应是质疑，如果无法质疑就会心生恐惧。还有一些人，他们对这个世界充满了好奇，渴望去接触自己从未考虑过的观念，希望经历那些之前未经历过的人生体验，这些使他们感到兴奋和满足。前一种人的心智是闭塞的，坚决地活在自己习惯的那个思维体系中；后一种人的心智是开放的，他们时刻准备着抛弃已有的思维体系，然后再将其重建。大多数工科生（尤其是工科女）属于前一种人，我却属于后一种。&lt;/p&gt;
&lt;p&gt;而我毕设答辩失败的根本原因，即在于这两种思维方式的冲突。或许对大多数计算机学院的老师或同学来说，研究大脑是件很&lt;a href=&quot;http://sealhuang.sinaapp.com/?p=191&quot;&gt;可笑&lt;/a&gt;的事情。当然失败并不是指没能通过（不然我就没心情写这篇文章了），而是说诸位老师将我的论文嘲讽了一番，并指出需要进行内容与格式上的较大修改才能符合计算机学院的要求。这时离论文终稿提交的截至时间还剩不到两天。万幸的是，另一位论文不符合『要求』的同学在回答提问时惹毛了诸位大佬，从而替我进了二辩，要不然估计我就真难顺利毕业了。&lt;/p&gt;
&lt;p&gt;答辩后的下午，我怀着失落与不安坐在实验室的座位上，虽然与实验室老师讨论了大致的修改方案，但还是无法安心地修改论文，就仿佛被人狠狠的揍了一拳，自己不仅没力气还手，还在时刻担心对方的下一记重击。除了对于不能毕业的恐惧，还有一个原因让我没法全心修改论文。那就是我始终认为本科论文没什么意义，根本不会有人真正在乎它的内容，花费如此之多的时间实在是有所不值。&lt;/p&gt;
&lt;p&gt;但生活总要继续，问题总要解决。吃过晚饭后，我像老板所说的那样『别管有没有意义』下决心跟论文死磕到底。有些事情就是这样，如果你决心达到目标，那你真的就会达到。我想这就是人类心智的强大之处，它不仅能让我们去追求那些美好的东西，也能让我们在枯燥无趣的工作中坚持下来。&lt;/p&gt;
&lt;p&gt;8号上午9点33分，我将打印好的论文终稿交给了学院的教务老师。我想，这是我对成为一名合格工科生的最后努力。此时校园里已到处飘起了象征着工科的金色绶带，四处可见庆祝毕业的兴奋面孔。我为自己没有放弃感到心满意足。&lt;/p&gt;
&lt;p&gt;9号，穿上学士服穿梭在校园里，大家情绪都很高涨。新主，音乐厅，绿园，图书馆，老教学区，怎么都拍不完的北航，到处载满了四年的记忆。雨过天晴的傍晚，清爽的风吹动着金黄绶带，仿佛置身在那片悬崖上的麦田。但误入麦田的孩子们都要离开了，因为他们已抬头看到了天空原来是那么广，那么蓝。&lt;/p&gt;
&lt;p&gt;忘了在哪儿看到过这么一句话，它说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;上天真的会眷顾那些勇敢选择自己的生活并坚持努力地走下去的孩子们。&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>用 Glossary 学习 Python : 名字空间及作用域</title>
   <link href="http://yangzetian.github.com/2012/05/13/glossary-python-1-namespace-scope"/>
   <updated>2012-05-13T15:32:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/05/13/glossary-python-1-namespace-scope</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;在《如何阅读一本书》中作者提到，分析型阅读的第一步应该是弄清楚书中每个术语或专业词汇的语义，如果作者提供了一个词汇表 (glossary)，那么就应该先好好将它读一读。我认为这条规则不仅对阅读理解书籍来说很有效，对读代码、文档等技术方面的材料来说也十分适用。因此我想到了最近自己一直在使用的 &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt; 语言，它的&lt;a href=&quot;http://docs.python.org&quot;&gt;官方文档&lt;/a&gt;中就有一个这样的&lt;a href=&quot;http://docs.python.org/glossary.html&quot;&gt;词汇表&lt;/a&gt;。在浏览了里面的条目后，我发现这个词汇表及其有用，对许多概念进行了精短的说明，且覆盖了 Python 语言的方方面面。因此我将其作为自己深入学习 Python 的一个入口，并打算写一系列的文章，每次从中挑选出与某一主题相关的词汇，对它们进行学习研究。&lt;/p&gt;
&lt;p&gt;最近对 Python 的名字空间与作用域机制很感兴趣，读了一些相关的文章，这里对其作一个小结。&lt;/p&gt;
&lt;p&gt;言归正传，在 Glossary 中与名字空间或作用域相关的词汇有:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;namespace&lt;/em&gt; : The place where a variable is stored. Namespces are implemented as dictionaries. There are local, global and built-in namespaces as well as nested namespaces in objectes (in methods). Namespaces support modularity by preventing naming conflicts…&lt;/p&gt;
&lt;p&gt;&lt;em&gt;nested scope&lt;/em&gt; : The ability to refer to a variable in encolsing definition. For instances, a function defined inside another function can refer to variables in the outer fucntion. Note that nested scopes work only for reference and not for assignment which will always write to the innermost scope. In contrast, local varibles both read and write in the innermost scope. Likewise. global variables read and write to the global namespace.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了理解 Python 的名字空间机制，首先需要明确的是 Python 中的变量 (variable) 与其他语言的不同。在 Python 中并不存在一般意义上的变量，它只有&lt;em&gt;名字&lt;/em&gt; (names) 和&lt;em&gt;对象&lt;/em&gt; (objects)。对象是数据实体，而名字是访问对象途径。名字通过&lt;em&gt;绑定&lt;/em&gt; (binding) 操作&lt;sup&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;被引入至程序中。此外绑定除了会使某个名字指代某个对象，还会给这个名字赋予一些额外的性质。下面这段话来自 &lt;a href=&quot;http://docs.python.org/reference/executionmodel.html#naming-and-binding&quot;&gt;Python 语言参考&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当我们在某个代码快内绑定一个名字时，它就是成为该代码块的局部变量 (local variable)。 而当我们在模块级别上绑定一个名字是，它就是一个全局变量 (global variable)。 由于模块也是一个代码快，因此这些变量即是全局的也是局部的。 如果在一个代码块中使用了一个未在该代码快内定义（绑定）的名字，它就被称为自由变量 (free variale)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在程序一旦写成之后，任何代码块中的任意变量都必定属于上述三种类型&lt;sup&gt;&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;之一，这是在生成字节码之前就确定下来的。因为这与虚拟机使用用哪种语句加载变量相关。比如下面这段代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



&lt;p&gt;函数 &lt;code&gt;f&lt;/code&gt; 的字节码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2           0 LOAD_CONST               1 (2)
            3 STORE_FAST               0 (l)

3           6 LOAD_GLOBAL              0 (g)
            9 STORE_FAST               1 (ll)
           12 LOAD_CONST               0 (None)
           15 RETURN_VALUE        &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出对于局部变量 &lt;code&gt;f&lt;/code&gt;，Python 使用的是 &lt;code&gt;LOAD_FAST/STORE_FAST&lt;/code&gt; 一类指令，而对于全局变量则使用 &lt;code&gt;LOAD_GLOBAL/STORE_GLOBAL&lt;/code&gt; 一类指令。&lt;/p&gt;
&lt;p&gt;绑定的作用之一就是确定变量的类型：不论一个变量在当前代码块中的哪里被绑定，它都被认为是局部的，因此该代码块内所有对其的使用都将指向它绑定的这个对象。这段话听起来十分坳口，我们用下面这个例子来说明：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



&lt;p&gt;函数 &lt;code&gt;f&lt;/code&gt; 对应的字节码为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2           0 LOAD_FAST                0 (x)
            3 STORE_FAST               1 (t)

3           6 LOAD_CONST               1 (10)
            9 STORE_FAST               0 (x)
           12 LOAD_CONST               0 (None)
           15 RETURN_VALUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，第一句加载变量 &lt;code&gt;x&lt;/code&gt; 时即使用的 &lt;code&gt;LOAD_FAST&lt;/code&gt; 指令，说明 Python 认为它是一个局部变量，而对 &lt;code&gt;x&lt;/code&gt; 的绑定却是在后面一条语句中才发生。这个例子说明了 Python 的变量类型机制 —— 变量类型被静态确定。虽然定义 &lt;code&gt;f&lt;/code&gt; 时不会报错，但在 &lt;code&gt;f&lt;/code&gt; 运行时会报出 &lt;code&gt;UnboundLocalError&lt;/code&gt; 的异常, 这个异常会在引用一个未绑定的局部变量时抛出。这似乎是个有点违反直觉的现象，按一般的理解，第一条语句中的 &lt;code&gt;x&lt;/code&gt; 应该是全局的，第二条语句不过是在本地重新生成了一个局部变量而已。但就像上文所说的，当定义好 &lt;code&gt;f&lt;/code&gt; 后，它里面的每个变量类型都已经确定了，尽管 &lt;code&gt;x&lt;/code&gt; 在第二条语句中才被绑定，但还是被认为是一个局部变量，既然是一个局部变量, 再运行时任何对这个名字的使用就会访问局部代码块中它所绑定的对象, 如果它还没被绑定，当然就应该报错。&lt;/p&gt;
&lt;p&gt;每个被引入的名字都被保存在某个名字空间里。而名字空间是和&lt;em&gt;代码块&lt;/em&gt; (block) 相互关联的。所谓代码块即指一段被当作一个单元执行的程序文本。诸如模块、函数体、类定义都是一个代码块。每个代码块都有一个属于自己的独立名字空间，且每个名字空间都有一个允许直接访问其内名字的的代码范围，在这个范围内这些名字都是可见的， 而在这个范围外，该名字空间的内的名字不能直接使用。这个代码范围即是该名字空间（中变量）的&lt;em&gt;作用域&lt;/em&gt; (scope)。&lt;/p&gt;
&lt;p&gt;现在让我们把注意力集中在代码块的局部变量&lt;sup&gt;&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;上, &lt;a href=&quot;http://docs.python.org/reference/executionmodel.html#naming-and-binding&quot;&gt;语言参考&lt;/a&gt;中说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个代码块中定义的局部变量的作用域为这个代码块本身。如果它定义在一个函数代码块中， 它的作用域将延伸至该代码块包含的所有内部代码块中，除非在子代码块里对其重新定义。 类代码块中定义的名字的作用域仅限于该代码块本身，它不会向类中的方法代码块扩展 —— 这包括生成器表达式，因为它们使用了函数作用域来实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了这几条规则，我们可以静态地推出在任意一个代码块被哪些名字空间的作用域所覆盖&lt;sup&gt;&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;，有如下几种情况：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;代码块自身的局部名字空间，该空间包含了在本代码块中绑定的所有名字&lt;/li&gt;
&lt;li&gt;所有包含该代码块的函数代码块的名字空间，它们的作用域按代码块的分布层层嵌套&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了这两种可能的作用域之外，Python 还规定了以下两个所有代码块均可见的名字空间:&lt;/p&gt;
&lt;ol start=&quot;3&quot; style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;代码块所在模块的全局名字空间，它包含了模块中的所有全局变量&lt;/li&gt;
&lt;li&gt;内建名字空间，它其实是 &lt;code&gt;__builtin__&lt;/code&gt; 模块的名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以把上面的这两个名字空间合称『全局名字空间』，它们的作用域为模块内任何代码块。&lt;/p&gt;
&lt;p&gt;当 Python 需要对一个变量解析其对应的对象时它会以上面列出的 1， 2， 3， 4 顺序 (即 &lt;code&gt;LEGB&lt;/code&gt;) 依次尝试，把在最里层名字空间内找到的名字绑定作为当前名字的引用。有一个例外是如果在代码块中用 &lt;code&gt;global&lt;/code&gt; 语句对一个变量进行了声明，那么在该代码块中所有对此名字进行解析时将跳过 1, 2 直接从 3 开始。比如下面这段代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



&lt;p&gt;将会输出 10。函数 &lt;code&gt;f&lt;/code&gt; 的字节码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2           0 LOAD_CONST               1 (10)
            3 STORE_GLOBAL             0 (x)
...         ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从中可以看到，&lt;code&gt;x&lt;/code&gt; 在赋值时即被当作是全局变量。这说明了两点：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;code&gt;global&lt;/code&gt; 语句可以覆盖一个名字在当前代码块中的其他绑定而将其强制设定为全局变量&lt;/li&gt;
&lt;li&gt;再次表明一个变量的类型是在运行前就被静态地确定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事实上，定义上面这个函数时 Python 编译器&lt;sup&gt;&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;会给出一个&lt;em&gt;语法警告&lt;/em&gt;，提醒你 &lt;code&gt;x&lt;/code&gt; 在全局声明前就被赋值。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;现在我们明白了 Python 中的名字、绑定、类型、代码块、名字空间、作用域等概念，再回顾一下最上面列出的那两个 Glossary 中的定义。如果你觉得已经完全理解了定义中说的每句话，每个词的含义，那就说明你理解 Python 的名字空间以及作用域了。&lt;/p&gt;
&lt;p&gt;对于那些想弄懂 CPython 是如何实现这些机制的人，请继续阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/&quot;&gt;Understanding UnboundLocalError in Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/&quot;&gt;Python internals: Symbol tables, part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/&quot;&gt;Python internals: Symbol tables, part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;常见的绑定操作包括函数定义，类定义，赋值语句等，一个特别的绑定操作是 &lt;code&gt;del&lt;/code&gt; 语句，出现在 &lt;code&gt;del&lt;/code&gt; 后面的变量讲被认为是局部变量。关于绑定操作更多的说明请参考: &lt;a href=&quot;http://docs.python.org/reference/executionmodel.html#naming-and-binding&quot;&gt;Naming and binding&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;这里所指的类型并不是变量值的类型 (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; 等)，而是指它是局部、自由还是全局变量。下同。&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;任何一个变量都必定是某个代码块的局部变量。&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;注意这里只是说确定被哪些名字空间覆盖，而没有说确定所有可以直接使用的变量，因为名字空间拥有的变量是动态地确定的。这也就是为什么 &lt;a href=&quot;http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;Tutorial&lt;/a&gt; 中说&lt;em&gt;作用域被静态地确定，动态地使用&lt;/em&gt;。&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;虽说 Python 不是一个编译语言，但还是有一个编译器前端的，它对源文件进行语法分析，生成句法树和符号表，并最终产生字节码供虚拟机执行。这些步骤属于 Python 的静态地带，变量的类型就是在其中确定的。深入的信息请参考&lt;a href=&quot;http://eli.thegreenplace.net&quot;&gt;Eli&lt;/a&gt; 的文章 &lt;a href=&quot;http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/&quot;&gt;Python internals: Working with Python ASTs&lt;/a&gt;&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>BUAA Story : slides using pandoc and dzslides</title>
   <link href="http://yangzetian.github.com/2012/05/10/buaa-story"/>
   <updated>2012-05-10T22:11:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/05/10/buaa-story</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;今天下午学校搞德育答辩，要求每个人做三分钟左右的展示。之前在&lt;a href=&quot;http://yihui.name/en/2012/04/fancy-html5-slides-with-knitr-and-pandoc/&quot;&gt;益辉&lt;/a&gt;的博客上看到过非常炫的 html5 &lt;a href=&quot;http://inundata.org/R_talks/meetup/&quot;&gt;幻灯片&lt;/a&gt;，所以趁这个机会自己也尝试了一把。实际证明效果还是不错的，打算以后就放弃 bearmer 转投 html5+css+js 的门下了。&lt;/p&gt;
&lt;p&gt;我的这个展示用 &lt;a href=&quot;http://markdown.tw/&quot;&gt;markdown&lt;/a&gt; 编写，之后借助 &lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;pandoc&lt;/a&gt; 转换成 &lt;a href=&quot;http://paulrouget.com/dzslides/&quot;&gt;dzslides&lt;/a&gt;。源文件可以从&lt;a href=&quot;http://github.com/yangzetian/BUAA-Story&quot;&gt;这里&lt;/a&gt;获取，也可以&lt;a href=&quot;http://yangzetian.github.com/BUAA-Story&quot;&gt;在线&lt;/a&gt;观看最终效果&lt;sup&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;这里顺便介绍一下目前我知道的 html 幻灯片制作方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一种就是我使用的 &lt;a href=&quot;http://paulrouget.com/dzslides/&quot;&gt;dzslides&lt;/a&gt;，它其实是一个 html 模板，利用 CSS3 实现了每张展示间的切换，它支持在幻灯片中直接使用 html5 元素。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二种比较方便的方法是使用 Google 提供的 html5 &lt;a href=&quot;http://code.google.com/p/html5slides/&quot;&gt;模板&lt;/a&gt;。用法和 dzslides 类似。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三种是绚丽的 &lt;a href=&quot;http://imakewebthings.com/deck.js/&quot;&gt;deck.js&lt;/a&gt;。这玩意儿真是太炫了，刚才提到的 R 介绍就是用它做的。可惜目前我还不懂 JavaScript，但有这么漂亮的应用，JavaScript 已经排在我的学习列表里了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;注意一定&lt;em&gt;不要&lt;/em&gt;用 IE 观看这个展示，推荐火狐或者 Chrome。另外由于这个展示里有很多图片，而我又是直接把图片放在 &lt;a href=&quot;http://github.com/yangzetian/BUAA-Story&quot;&gt;Github&lt;/a&gt; 上的，所以加载速度会很慢。我比较推荐把源码库克隆到本地后观看，如果你执意在线查看，那好，请打开链接后泡杯茶，待三十分钟后再回来 :-)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>民谣与博客</title>
   <link href="http://yangzetian.github.com/2012/04/19/folk-blog"/>
   <updated>2012-04-19T21:09:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/04/19/folk-blog</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;昨晚在图书馆六层，借着不太明亮的灯光和偶尔闪过的雷光，终于读完了&lt;a href=&quot;http://book.douban.com/subject/3178741/&quot;&gt;《来自民间的叛逆》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;书中让我印象最深刻的不是那些美国民谣歌手们成功的曲折过程，也不是他们糜烂的个人生活，而是作者在前言中对本书写作过程的介绍。作者从95年开始撰写本书，直至01年底完成80万字的初稿，最后删去约20万字后于03年出版。按作者自己的说法，这本书花去了他七年间全部的业余时间。这样的恒心和毅力不得不让人肃然起敬。作者这般心血的最终成果，便是展现在我面前的这本由700多页密密麻麻小字讲述的美国20年代民谣史，另外作者得以从此以写字为生，成为文化工作者。&lt;/p&gt;
&lt;p&gt;这本书绝不仅仅只是一部民谣史，它更像是美国文化史，除了主要讲述的那些民谣歌手，还几乎介绍了美国20年代发生的所有重大政治、经济、文化事件。也只有在这样详细介绍的美国社会大背景下，那些由借音乐之名引发的其他故事才更生动精彩。书中我最喜欢的内容包括60年代的嬉皮运动；所有和毒品、迷幻剂相关的人物事迹；两位被人忽视的民谣歌手：&lt;a href=&quot;http://en.wikipedia.org/wiki/Tim_Buckley&quot;&gt;蒂姆·巴克利&lt;/a&gt;（Tim Buckley）和&lt;a href=&quot;http://music.douban.com/musician/102593/&quot;&gt;尼克·德雷克&lt;/a&gt;（Nick Drake）。其中在介绍德雷克那张『Five Leaves Left』专辑时与欧·亨利那篇『The Last Leaf』的类比让人叫绝，也更加反衬出德雷克的不幸的一生。&lt;/p&gt;
&lt;p&gt;回想自从上月5号在二层新书架上见到这本书至现在已过去一个半月，这期间我并不是只读了这本书。但有趣的是，这本书将最近读的另外两本书串联了起来，它们分别是&lt;a href=&quot;http://book.douban.com/subject/1223765/&quot;&gt;《请宰了我》&lt;/a&gt;和&lt;a href=&quot;http://book.douban.com/subject/2090728/&quot;&gt;《LSD：我的问题少年》&lt;/a&gt;，前一本同样是介绍美国音乐故事的，但主角换成了60年代末萌芽并在70年代风靡英美的朋克摇滚，后一本则是 LSD 的合成者艾伯特·霍夫曼（Albert Hofmann）亲自书写的 LSD 逸事。我向来着迷于那些不寻常的奇异人物与事件，这几本书充分地满足了我的好奇心。&lt;/p&gt;
&lt;p&gt;当然除了读书，这四十多天来自己还做了很多事，但大多数都希望自己没有做才好，就比如中期答辩这类事，只是会凭白增加青春之苦闷罢了。但有一件事却十分有价值，那便是开了这个博客。虽说大学四年多半过得浑浑噩噩，但偶尔还是会有提笔写点东西的冲动。可惜我这个人比较懒，对折腾网页这类东西更是讨厌，开博客几乎从未进入过我的日常计划中。我基本上每天食堂图书馆自习室，要是有些情绪实在憋不住了就在校内上扔个日志完事。后来注销校内，便转战豆瓣日记，还在上面写了生平第一个技术贴。这两样东西还挺符合我的要求，因为它们都够简单，不用涉及 HTML。用 HTML 标记写文章对我来说绝对不可忍受，那些 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 简直就像是散落在文字里的污渍，毫无美感可言。&lt;/p&gt;
&lt;p&gt;后来我遇到了 &lt;a href=&quot;http://wowubuntu.com/markdown/index.html&quot;&gt;Markdown&lt;/a&gt;、&lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;、&lt;a href=&quot;http://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;、&lt;a href=&quot;http://johnmacfarlane.net/pandoc&quot;&gt;Pandoc&lt;/a&gt;，再后来就有了这个博客。一开始我只是把它当作一个笔记本，作用不过就是充当 Linux 下的 &lt;a href=&quot;http://www.evernote.com&quot;&gt;Evernote&lt;/a&gt;。利用 &lt;a href=&quot;http://jekyllbootstrap.com&quot;&gt;Jekyll-Bootstrap&lt;/a&gt; 和一个已有&lt;a href=&quot;http://themes.jekyllbootstrap.com/preview/the-minimum&quot;&gt;主题&lt;/a&gt;迅速搭建出一个博客原型。在熬过了中期答辩的那几天后我急需一个东西来发泄体内堆积过多的荷尔蒙，正好当时这个主题有许多我不满意的地方，因此我好好地荒废了那几天工作日，全心全意扑在了折腾博客上。经过某个彻夜奋战，我完成了一个里程碑式的改动，觉得这个博客终于算是一个可以拿出去给人看的东西了。没想到昨晚到 Windows 下浏览的时候却发现字体完全混乱，而且样式也出了问题。无奈只好再花时间折腾，要是让实验室老师知道花了这么多时间没好好干活，估计会被骂得很惨吧。&lt;/p&gt;
&lt;p&gt;在调整字体的过程中，这个系列&lt;a href=&quot;http://www.cnblogs.com/ruxpinsp1/archive/2008/04/29/font-in-front-end-development-1.html&quot;&gt;博文&lt;/a&gt;给了我很大帮助，在这里谢谢原作者。此外有个浏览器插件叫 &lt;a href=&quot;http://chengyinliu.com/whatfont.html&quot;&gt;WhatFont&lt;/a&gt;，可以实时查看当前页面中的文字所使用的字体，是个不错的小工具。现在这个博客基本上已经比较符合我对它的期望，我也不想再花时间在其外观的设置上，毕竟方便快捷地记录下自己的思考过程和最终想法才是它最重要的功能。在此列出所有在原主题基础上作出的改动：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;将 Pandoc 设为 Jekyll 的 Markdown 渲染器。&lt;/li&gt;
&lt;li&gt;正文与标题的字体均优先选用 &lt;a href=&quot;http://www.google.com/webfonts&quot;&gt;Google Web Fonts&lt;/a&gt; 中的 &lt;a href=&quot;http://www.google.com/webfonts/specimen/Droid+Sans&quot;&gt;Droid Sans&lt;/a&gt;。中文方面 Linux 下首选&lt;a href=&quot;http://wenq.org/index.cgi?MicroHei&quot;&gt;文泉驿微米黑&lt;/a&gt;，Windows 下为微软雅黑，Mac 下则是冬青黑体。&lt;/li&gt;
&lt;li&gt;给每篇文章增加了发表时间。很多 Jekyll 的主题都默认不显示文章发表的具体时间，而是只到发布日期，这点感觉还是很奇怪的。&lt;/li&gt;
&lt;li&gt;增加代码高亮的方式。其实原本 Jekyll 即支持代码高亮，但借助 Pandoc 代码高亮可以用更&lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html&quot;&gt;简洁&lt;/a&gt;的 Markdown 语法实现。&lt;/li&gt;
&lt;li&gt;添加 &lt;a href=&quot;http://disqus.com&quot;&gt;Disqus&lt;/a&gt; 评论。&lt;/li&gt;
&lt;li&gt;添加 &lt;a href=&quot;http://feedburner.google.com&quot;&gt;FeedBurner&lt;/a&gt; 订阅。&lt;/li&gt;
&lt;li&gt;添加 &lt;a href=&quot;http://www.google.com/analytics&quot;&gt;GoogleAnalytics&lt;/a&gt; 页面分析。&lt;/li&gt;
&lt;li&gt;增加博客图标。待完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于写作的完整过程，我是这样进行的：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;用 &lt;code&gt;rake post&lt;/code&gt; 新建一篇空白 Markdown 文件。&lt;/li&gt;
&lt;li&gt;用 &lt;a href=&quot;http://www.vim.org&quot;&gt;Vim&lt;/a&gt; 加 Pandoc 扩展&lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html&quot;&gt;语法&lt;/a&gt;写文章。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;jekyll --safe&lt;/code&gt; 在本地生成所有内容。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;git push&lt;/code&gt; 将内容送至 Github 远端&lt;a href=&quot;http://yangzetian.github.com/YangBlog&quot;&gt;库&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置好这个写作系统后，我可以将自己的注意力全部放在文章的内容上，而不被其他因素打扰，简直就跟以前在校内、豆瓣上写日志一样。后来我又推荐了好友&lt;a href=&quot;http://marcieinred.github.com&quot;&gt;萝卜&lt;/a&gt;以这种方式开博，虽然他一开始不怎么乐意，不过后来还是经受不住零成本博客的诱惑，跳进了这个大坑。此外他是个前端高人，喜欢直接写 HTML ，没有采用 Jekyll + Markdown。我想总有一天他会后悔的 :P。&lt;/p&gt;
&lt;p&gt;读完《叛逆》后本来是想写一篇基调压抑的文章来总结最近低靡的境况，可写着写着心情却变好了起来，这大概就是博客或者说是写作的魅力吧。对我来说它还有一个吸引我的地方，因为我一直比较支持&lt;a href=&quot;http://zh.wikipedia.org/zh/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89&quot;&gt;存在主义&lt;/a&gt;的观点，可近来却常常无法真切地感受到自己的存在，只有看着这个博客的时候，才能确信自己还有颗自主独立的心灵。&lt;/p&gt;
&lt;p&gt;如果说民谣是歌手们对于社会不公的抗议，那这个博客或许就是我对青春成长的叛逆。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>为 Jekyll 装上瑞士军刀 Pandoc</title>
   <link href="http://yangzetian.github.com/2012/04/15/jekyll-pandoc"/>
   <updated>2012-04-15T01:12:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/04/15/jekyll-pandoc</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; }
code &gt; span.dt { color: #902000; }
code &gt; span.dv { color: #40a070; }
code &gt; span.bn { color: #40a070; }
code &gt; span.fl { color: #40a070; }
code &gt; span.ch { color: #4070a0; }
code &gt; span.st { color: #4070a0; }
code &gt; span.co { color: #60a0b0; font-style: italic; }
code &gt; span.ot { color: #007020; }
code &gt; span.al { color: #ff0000; font-weight: bold; }
code &gt; span.fu { color: #06287e; }
code &gt; span.er { color: #ff0000; font-weight: bold; }
  &lt;/style&gt;
  &lt;script src=&quot;https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Jekyll 原生支持 &lt;code&gt;maruku&lt;/code&gt;，&lt;code&gt;rdiscount&lt;/code&gt;，&lt;code&gt;kramdown&lt;/code&gt;，&lt;code&gt;redcarpet&lt;/code&gt; 等 markdwon 渲染器，它们各有利弊。个人认为 Maruku 虽然是 Jekyll 的默认选择，却是最不适合 中文博客的，因为它对中文列表的支持不好。Rdiscount 算是中归中举，但对于 &lt;a href=&quot;http://www.mathjax.org&quot;&gt;MathJax&lt;/a&gt; 的用户来说却比较头疼，容易出诡异的问题。Github 在后台则选用了 Redcarpet 作为其文本渲染器，因为它安全性高且性能卓越，同时它在基本 Markdown 语法的基础上增加了一些自己的特性。Kramdown 是这几个当中对基础 Markdown 语法拓展最多，也是最方便使用的，但跟这篇文章的主角 &lt;a href=&quot;http://johnmacfarlane.net/pandoc&quot;&gt;Pandoc&lt;/a&gt; 来比，它就相形见绌了。&lt;/p&gt;
&lt;p&gt;首先介绍一下 &lt;a href=&quot;http://johnmacfarlane.net/pandoc&quot;&gt;Pandoc&lt;/a&gt;，它的功能是在多种常见的标记语言进行相互转换，其中包括 Markdown, reStructuredText, Textilte, HTML, \(\LaTeX\) 等。利用它，你可以用简单的 Markdown 语法生成与 \(\LaTeX\) 一致的文档，还可以写 Beamer 演示文稿。更强大的是，它还能将以上提到的这些语言所写文件转换成 &lt;em&gt;doc&lt;/em&gt; 文档，这对我们这些体制内码农很是实用。下面这张图展示了 Pandoc 让人吃惊 的功能集，不愧为文件转换中的瑞士军刀：&lt;/p&gt;
&lt;img src=&quot;http://johnmacfarlane.net/pandoc/diagram.png&quot; alt=&quot;pandoc is awsome!&quot; width=&quot;650&quot;/&gt;
&lt;p&gt;对于用 Jekyll 写博客的人来说它还有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持在 Markdown 文档中直接使用 \(\LaTeX\) 公式，最终生成的网页更是可以选择以图片、MathJax、jsMath 等等方式显示公式&lt;/li&gt;
&lt;li&gt;支持代码高亮，并自带多种高亮方案可选。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这两个功能都可以通过设置 Jekyll 实现，但由于我对 Pandoc 已经欲罢不能，其它的渲染器都再也看不上眼了。下面我就来介绍如何让 Jekyll 使用 Pandoc 作为 Markdown 渲染器。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;首先需要说明的是，由于 &lt;a href=&quot;http://pages.github.com&quot;&gt;Github Pages&lt;/a&gt; 并不支持 Pandoc，所以就不能将包含 Markdown 日志等文件的 Jekyll 目录直接放到 Github 库上指望 Github 帮我们渲染它们，而是需要在本地将站点完全生成好后再将它送到某一库里。有人可能觉得麻烦，但对我 来说却是一个优点，因为这样做会使 Github Pages 更新速度大大加快，不会出现今晚提交，明早才被更新好的情况。&lt;/p&gt;
&lt;p&gt;先要安装 Pandoc，具体过程请参考：&lt;a href=&quot;/2012/03/31/pandoc-cabal&quot;&gt;安装 GHC，Cabal/Cabal-install 及 Pandoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果本机上已安装了 Jekyll 则需将其删除，因为下面要使用修改过的 Jekyll。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(sudo) gem uninstall jekyll&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果本机还未安装 Jekyll，大概你也没装 Ruby 了，那么请执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(sudo) yum install ruby ruby-devel rubygems
(sudo) gem install liquid classifier directory_watcher maruku kramdown albino &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载修改过的 Jekyll，它已被修改成 Pandoc 友好型 :)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:yangzetian/jekyll&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/dsanson/jekyll&quot;&gt;这里&lt;/a&gt; 有 &lt;a href=&quot;http://www.davidsanson.com/&quot;&gt;dsanson&lt;/a&gt; 的版本，作者称可以解决 Github Pages 不支持 Pandoc 的问题，不过我试了一晚愣是没搞定，所以自己写了一个。其实原理很简单，即修改&lt;code&gt;lib/jekyll/converters/markdown.rb&lt;/code&gt; 文件，在 &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;convert&lt;/code&gt; 中按照其它渲染器的格式增加一个 &lt;code&gt;pandoc&lt;/code&gt; 判断即可。)&lt;/p&gt;
&lt;p&gt;安装 Pandoc-ruby，一个 Pandoc 的 Ruby 接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(sudo) gem install pandoc-ruby&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 Jekyll：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gem build jekyll.gemspec
(sudo) gem install -l jekyll-0.11.2.gem&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 Jekyll 配置文件 &lt;code&gt;_config.yml&lt;/code&gt; 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;markdown: pandoc
pandoc:
    extensions: [mathjax, standalone]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的 &lt;code&gt;extensions&lt;/code&gt; 并不唯一，可以将任何 Pandoc 支持的选项加入其中。&lt;/p&gt;
&lt;p&gt;好了，现在我们博客中所有的 Markdown 文件已经是由 Pandoc 渲染的了！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;下面是 Pandoc 演示环节&lt;/p&gt;
&lt;p&gt;从&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$e^x = \sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到&lt;/p&gt;
&lt;p&gt;\(e^x = \sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n\)&lt;/p&gt;
&lt;p&gt;从&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.python .numberLines}
class FSM(object):

&amp;quot;&amp;quot;&amp;quot;This is a Finite State Machine (FSM).
&amp;quot;&amp;quot;&amp;quot;

def __init__(self, initial_state, memory=None):

    &amp;quot;&amp;quot;&amp;quot;This creates the FSM. You set the initial state here. The &amp;quot;memory&amp;quot;
    attribute is any object that you want to pass along to the action
    functions. It is not used by the FSM. For parsing you would
    typically pass a list to be used as a stack. &amp;quot;&amp;quot;&amp;quot;

    # Map (input_symbol, current_state) --&amp;gt; (action, next_state).
    self.state_transitions = {}
    # Map (current_state) --&amp;gt; (action, next_state).
    self.state_transitions_any = {}
    self.default_transition = None
    ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到&lt;/p&gt;
&lt;table class=&quot;sourceCode python numberLines&quot;&gt;&lt;tr class=&quot;sourceCode&quot;&gt;&lt;td class=&quot;lineNumbers&quot;&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;sourceCode&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FSM(&lt;span class=&quot;dt&quot;&gt;object&lt;/span&gt;):

&lt;span class=&quot;co&quot;&gt;&amp;quot;&amp;quot;&amp;quot;This is a Finite State Machine (FSM).&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;ot&quot;&gt;self&lt;/span&gt;, initial_state, memory=&lt;span class=&quot;ot&quot;&gt;None&lt;/span&gt;):

    &lt;span class=&quot;co&quot;&gt;&amp;quot;&amp;quot;&amp;quot;This creates the FSM. You set the initial state here. The &amp;quot;memory&amp;quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    attribute is any object that you want to pass along to the action&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    functions. It is not used by the FSM. For parsing you would&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    typically pass a list to be used as a stack. &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
     
    &lt;span class=&quot;co&quot;&gt;# Map (input_symbol, current_state) --&amp;gt; (action, next_state).&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;self&lt;/span&gt;.state_transitions = {}
    &lt;span class=&quot;co&quot;&gt;# Map (current_state) --&amp;gt; (action, next_state).&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;self&lt;/span&gt;.state_transitions_any = {}
    &lt;span class=&quot;ot&quot;&gt;self&lt;/span&gt;.default_transition = &lt;span class=&quot;ot&quot;&gt;None&lt;/span&gt;
    ...&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.davidsanson.com&quot;&gt;dsanson 的博客&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>安装 GHC, Cabal/Cabal-install 及 Pandoc</title>
   <link href="http://yangzetian.github.com/2012/03/31/pandoc-cabal"/>
   <updated>2012-03-31T00:00:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/03/31/pandoc-cabal</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;GHC 是 Glasgow Haskell Compiler 的简称，也是 Haskell Platform 的基础。最新的版本可以从&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;进入最新版本的下载页面后有两个选择，一是二进制包，二是纯源码包。如果想从纯源码包下载，需要你本机上已装有某个版本的 ghc ，因为这个源码的大部分就事用 Haskell 写的。&lt;/p&gt;
&lt;p&gt;由于种种缘故我把之前 yum 安装的 ghc 给删了，所以这里我选择 ghc 的 linux_x86 平台二进制包。&lt;/p&gt;
&lt;p&gt;下好安装包后即是通用的 make 过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xjvf ghc-7.x.x-i386-linux-unkown.tar.bz2
cd ghc-7.x.x
./configure
make install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以开始安装 Cabal/Cabal-install了。&lt;/p&gt;
&lt;p&gt;Cabal 是 Haskell 的一个 package，提供了一个 Haskell 包安装框架，方便了 Haskell 包的管理。而 Cabal-install 则是另一个 Haskell 包安装库，它提供了 &lt;code&gt;cabal&lt;/code&gt; 命令行程序，该程序在安装新包时会自动解决包依赖关系，大大方便了 Haskell 包的安装。&lt;/p&gt;
&lt;p&gt;官方的建议是安装 Haskekll Platform，它整合了 GHC，Cabal，Cabal-install 等常用工具。由于我觉得 fedora repo 中的 HP 版本过老，编译 HP 又需要其他很多东西，所以就没有选取这个方案，而是自己安装 Cabal。&lt;/p&gt;
&lt;p&gt;其实 Cabal 和 Cabal-install 只要安装后者就可以了，因为安装 Cabal-install 时用的 &lt;code&gt;bootstrap&lt;/code&gt; 程序会自动下载 Cabal-install 所依赖的包，其中当然包括 Cabal。但如果你只安装前者那么后者还需要手动安装。&lt;/p&gt;
&lt;p&gt;虽说可以从 &lt;a href=&quot;http://hackage.haskell.org/package/cabal-install&quot;&gt;hackage&lt;/a&gt; 中下载 Cabal-install，但版本实在太老了。我选择从&lt;a href=&quot;http://darcs.haskell.org/cabal-branches/&quot;&gt;开发库&lt;/a&gt;中下载最新的稳定版本安装。这里有一个需要注意的是一定要保证你所用的 Cabal 版本与 Cabal-install 版本一致，也就是说从开发库中同一个版本文件夹中下载 Cabal 和 Cabal-install，否则安装时会出现麻烦。所以最好的办法就是不安装 Cabal 而直接安装 Cabal-install，这样永远不会出现冲突问题。&lt;/p&gt;
&lt;p&gt;我选择的是 &lt;a href=&quot;http://darcs.haskell.org/cabal-branches/cabal-1.14/&quot;&gt;Cabal-1.14&lt;/a&gt; 版本，把这个链接里所有的文件都用 &lt;code&gt;wget&lt;/code&gt; 下载到本地。命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -r -np -p http://darc.haskell.org/cabal-branches/cabal-1.14/cabal-install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入Cabal-install目录后执行&lt;code&gt;sh bootstrap.sh&lt;/code&gt;，即可完成安装。如果在安装过程中出现问题，大多是因为系统缺少一些库，比如 &lt;code&gt;gmp-devel&lt;/code&gt;，&lt;code&gt;zlib-devel&lt;/code&gt; 等，需要自行用 &lt;code&gt;yum&lt;/code&gt; 搞定。&lt;/p&gt;
&lt;p&gt;安装完成Cabal-install 后，将cabal程序所在目录加入PATH中，再执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cabal update
cabal install pandoc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，现在可以享受pandoc给我们带来的便利了！&lt;/p&gt;
&lt;p&gt;pandoc的使用请参考下面的&lt;em&gt;Links&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://johnmacfarlane.net/pandoc/demos.html&quot;&gt;Pandoc Demos&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html&quot;&gt;Pandoc User’s Guide&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://chen.yanping.me/cn/blog/2012/03/13/pandoc/&quot;&gt;一份中文简介&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>Markdown 中文列表抽风</title>
   <link href="http://yangzetian.github.com/2012/03/28/markdown"/>
   <updated>2012-03-28T16:53:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/03/28/markdown</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;用 markdown 写带中文的列表时发现 jekyll 生成的网页中有的可以正常显示，有的则不行。折腾半天，发现如果列表项中含有英文字母等非中文字符，就可以正确显示，纯中文的那些打死也不行。&lt;/p&gt;
&lt;p&gt;上网查后得知原来是 jeklly 默认 markdown 引擎 maruku 的问题，将引擎改为 rdiscount 即可。做法是修改 &lt;code&gt;_config.yml&lt;/code&gt; 文件，在 &lt;code&gt;pygments: true&lt;/code&gt; 上面添加一行 &lt;code&gt;markdown: rdiscount&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.douban.com/note/147668553/&quot;&gt;markdown 渲染引擎折腾记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.v2ex.com/t/28800&quot;&gt;中文清单 lists 问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>Vim 拾遗</title>
   <link href="http://yangzetian.github.com/2012/03/27/vim"/>
   <updated>2012-03-27T13:04:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/03/27/vim</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vimim&quot;&gt;VimIm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#markdown&quot;&gt;markdown syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vimfold&quot;&gt;vim fold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;vimim&quot;&gt;
VimIm
&lt;/h2&gt;

&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;下载 &lt;a href=&quot;http://vim.sourceforge.net/scripts/download_script.php?src_id=17150/&quot;&gt;vimim.vim&lt;/a&gt; 至 &lt;code&gt;/usr/share/vim73/plugin&lt;/code&gt; 或 &lt;code&gt;/home/.vim/plugin&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;下载 &lt;a href=&quot;http://vimim-data.googlecode.com/svn/trunk/data/vimim.pinyin.txt/&quot;&gt;vimim.pingyin.txt&lt;/a&gt;，&lt;a href=&quot;http://vimim.googlecode.com/svn/trunk/plugin/vimim.cjk.txt/&quot;&gt;vimim.cjk.txt&lt;/a&gt; 至相同目录&lt;/li&gt;
&lt;li&gt;两种工作模式：
&lt;ul&gt;
&lt;li&gt;在插入模式下输入拼音，按 CTRL-^ 直接将拼音转换为汉字。&lt;/li&gt;
&lt;li&gt;在任意模式下按 CTRL-_， 进入动态输入模式，此模式与普通输入法类似&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; vimim.cjk.txt 是一个数码字库，如果需要拼音输入或五笔输入法需配套相应的其他字库 &lt;a href=&quot;http://groups.google.com/forum/?fromgroups#!topic/vimim/zWdi6QqKdLk/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;links&quot;&gt;Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vim.sourceforge.net/scripts/script.php?script_id=2506&quot;&gt;sourceforge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vimim.googlecode.com/svn/vimim/vimim.big5.html#cloud&quot;&gt;google code page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!topic/vimim/&quot;&gt;gogole groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/vimim-data/&quot;&gt;第三方词库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id='markdown'&gt;
markdown vim语法高亮
&lt;/h2&gt;

&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;下载 &lt;a href=&quot;http://plasticboy.com/dox/vim-markdown.zip&quot;&gt;mkd.vim.tar.gz&lt;/a&gt;，解压至 &lt;code&gt;.vim/&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;里面包含两个文件夹：&lt;code&gt;ftdetect&lt;/code&gt; 和 &lt;code&gt;syntax&lt;/code&gt;，第一个用于设置 vim 的文件关联，第二个是真正的 syntax 文件&lt;/li&gt;
&lt;li&gt;如需将某种文件后缀关联为 markdown 类型，需要在 &lt;code&gt;ftdetect/mkd.vim&lt;/code&gt; 中添加后缀&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;links-1&quot;&gt;Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://plasticboy.com/markdown-vim-mode/&quot;&gt;mkd blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/plasticboy/vim-markdown/&quot;&gt;mkd github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id='vimfold'&gt;
vim 折叠相关命令
&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;set foldenable/nofoldenable 
set foldmethod=syntax/indent...
set foldlevel=0/1/2...&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;links-2&quot;&gt;Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.chinaunix.net/newsoft/vi/doc/fold.html&quot;&gt;chinaunix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 <entry>
   <title>Linux 小窍门札记</title>
   <link href="http://yangzetian.github.com/2012/03/22/linux-tricks"/>
   <updated>2012-03-22T20:33:00+08:00</updated>
   <id>hhttp://yangzetian.github.com/2012/03/22/linux-tricks</id>
   <content type="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;这里用来记录Linux使用过程中得到的一些零碎却非常实用的小技巧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;yum&quot;&gt;yum&lt;/h2&gt;
&lt;p&gt;查找哪个包提供了&lt;code&gt;makeinfo&lt;/code&gt;程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum provides *bin/makeinfo&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;rpm&quot;&gt;rpm&lt;/h2&gt;
&lt;p&gt;查找某个包的相关文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpm -qs libgfortran&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;zip&quot;&gt;zip&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;unzip xxx.zip -d destdir&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;tar&quot;&gt;tar&lt;/h2&gt;
&lt;p&gt;将foo1，foo2打包至目标target&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar czf dir/to/target.tar.gz foo1 foo2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将target.tar.gz内容抽取至foo目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir foo; tar xzf target.tar.gz --directory=foo&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;z&quot;&gt;7z&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;7z e xxx.7z -o{DIR}&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;screenshot&quot;&gt;screenshot&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;scrot -s&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;gnome-快捷键&quot;&gt;Gnome 快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Terminal缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Crtl-_  || Crtl-+&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入系统剪切板的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Shift-Ins&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;bash-快捷键&quot;&gt;Bash 快捷键&lt;/h2&gt;
&lt;h3 id=&quot;命令行编辑&quot;&gt;命令行编辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;移动至行首或行尾 &lt;code&gt;Crtl-a || Crtl-e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按单词前移或后移 &lt;code&gt;Alt-f || Alt-b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除至行首或行尾 &lt;code&gt;Ctrl-u || Ctrl-k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;回删一个词 &lt;code&gt;Ctrl-w || Alt-Backspace || Esc-Backspace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后删一个词 &lt;code&gt;Alt-d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;粘贴至光标后 &lt;code&gt;Ctrl-y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;命令行历史&quot;&gt;命令行历史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;上一条命令 &lt;code&gt;!!&lt;/code&gt; | &lt;code&gt;!!:p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上条以xx开头的命令 &lt;code&gt;!xx&lt;/code&gt; || &lt;code&gt;!xx:p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参数: &lt;code&gt;!*&lt;/code&gt; || &lt;code&gt;!$&lt;/code&gt; || &lt;code&gt;!*:p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换参数 &lt;code&gt;^foo^fooo&lt;/code&gt; || &lt;code&gt;^foo^fooo^&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;wget&quot;&gt;wget&lt;/h2&gt;
&lt;p&gt;从&lt;URL&gt;下载整个文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -c -r -np -k -L -p &amp;lt;URL&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定下载目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -P &amp;lt;dir&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以30秒为间隔不断重新请求下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -t 0 -w 31 -c &amp;lt;URL&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
 </entry>
 
 
</feed>
